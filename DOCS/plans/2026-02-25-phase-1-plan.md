# Task 1.1: WebGL2 Instanced Grid Renderer ‚Äî Architecture

## Core Idea
One instanced draw call renders the entire grid. Each cell = one instance of a unit quad. A font atlas texture maps char indices to glyphs. Position is derived from gl_InstanceID ‚Äî no per-instance position data needed.

## File Structure
```
src/renderers/
  canvas-renderer.js        ‚Üê existing
  webgl2-renderer.js        ‚Üê Task 1.1 (main)
src/rendering/
  font-atlas.js             ‚Üê charset ‚Üí atlas texture + UV lookup
  instance-buffer.js        ‚Üê frame + canvas ‚Üí Float32Array (pure math, no GL)
  shaders.js                ‚Üê GLSL source strings (inline, no file loading)
  ```
## Public API Contract (mirrors canvas-renderer exactly)
```js
function createWebGL2Renderer(canvasEl, grid, options = {}) {
  // options: { fontSize?, showGrid?, fps?, onFrameChange? }
  
  return {
    renderFrame(),           // render current frame
    nextFrame(),             // advance + render
    prevFrame(),             // rewind + render  
    goTo(index),             // jump + render
    play(),                  // start animation loop
    pause(),                 // stop animation loop
    stop(),                  // pause + goTo(0)
    togglePlay(),            // returns new isPlaying
    setGrid(newGrid),        // swap grid, rebuild atlas if charset changed
    setOptions(newOptions),  // fontSize/showGrid/fps/onFrameChange
    eventToGrid(event),      // ‚Üí { gridX, gridY, pixelX, pixelY }
    destroy(),               // release GL resources
    get currentFrame,        // index
    get frameCount,          // grid.frames.length
    get playing,             // bool
    get cellSize,            // { width, height }
  };
}
```
- Drop-in swap: anywhere createRenderer works, createWebGL2Renderer works.

## Font Atlas Design (font-atlas.js)
```
Input:  charset string, fontSize, fontFamily
Output: { texture: ImageData, uvMap: Map<char, {u, v, w, h}>, cols, rows, cellW, cellH }
```
- Render each unique char in charset to an OffscreenCanvas (fallback: document.createElement('canvas'))
- White text on transparent black ‚Äî shader multiplies by fg color
- Pack into a grid layout (e.g., 16 chars per row)
- Atlas texture is power-of-2 padded
- Space char gets an explicit entry (index 0)
- defaultChar always present, used for cells not in charset
- Rebuild only when charset or fontSize changes

## Instance Buffer Layout (instance-buffer.js)
Per-instance: 5 floats, 20 bytes

Attribute	| Type	| Divisor	| Description
--------- |-------|---------|------------
a_charIndex	| float	| 1	| Index into atlas UV map
a_fgR	| float	| 1	| Foreground red (0‚Äì1)
a_fgG	| float	| 1	| Foreground green (0‚Äì1)
a_fgB	| float	| 1	| Foreground blue (0‚Äì1)
a_density	| float	| 1	| Density (0‚Äì1), for future effects

- Total buffer: width √ó height √ó 5 √ó 4 bytes

200√ó100 = 400KB ‚úì
500√ó500 = 5MB ‚úì
1000√ó1000 = 20MB (viable, note for future viewport culling)

### Position is NOT in the buffer. Computed in vertex shader:
```glsl
int cellX = gl_InstanceID % int(u_gridSize.x);
int cellY = gl_InstanceID / int(u_gridSize.x);
```
- Build function is pure ‚Äî no GL dependency:
```js
Build function is pure ‚Äî no GL dependency:
```
## Shaders (shaders.js)
- Vertex:
```glsl
#version 300 es
in vec2 a_quad;          // unit quad corners (0,0)‚Üí(1,1), 4 verts
in float a_charIndex;    // per-instance
in float a_fgR, a_fgG, a_fgB;  // per-instance
in float a_density;      // per-instance

uniform vec2 u_gridSize;     // (width, height) in cells
uniform vec2 u_cellSize;     // pixel size per cell
uniform vec2 u_resolution;   // canvas pixel size
uniform vec2 u_atlasGrid;    // atlas layout (cols, rows)

out vec2 v_uv;
out vec3 v_fg;
out vec2 v_cellLocal;    // for grid lines
out float v_density;

void main() {
  float cellX = float(gl_InstanceID % int(u_gridSize.x));
  float cellY = float(gl_InstanceID / int(u_gridSize.x));

  vec2 pos = (vec2(cellX, cellY) + a_quad) * u_cellSize;
  gl_Position = vec4((pos / u_resolution) * 2.0 - 1.0, 0.0, 1.0);
  gl_Position.y *= -1.0;

  // Atlas UV
  int idx = int(a_charIndex);
  float au = float(idx % int(u_atlasGrid.x)) / u_atlasGrid.x;
  float av = float(idx / int(u_atlasGrid.x)) / u_atlasGrid.y;
  v_uv = vec2(au, av) + a_quad / u_atlasGrid;

  v_fg = vec3(a_fgR, a_fgG, a_fgB);
  v_cellLocal = a_quad;
  v_density = a_density;
}
```
### Fragment
```glsl
#version 300 es
precision mediump float;

in vec2 v_uv;
in vec3 v_fg;
in vec2 v_cellLocal;
in float v_density;

uniform sampler2D u_atlas;
uniform vec3 u_bg;
uniform float u_showGrid;
uniform vec3 u_gridColor;

out vec4 outColor;

void main() {
  // Grid lines
  if (u_showGrid > 0.5) {
    float edge = 0.03;
    if (v_cellLocal.x < edge || v_cellLocal.y < edge) {
      outColor = vec4(u_gridColor, 1.0);
      return;
    }
  }

  float alpha = texture(u_atlas, v_uv).a;
  outColor = vec4(mix(u_bg, v_fg, alpha), 1.0);
}
```
## Initialization Flow
```text
createWebGL2Renderer(canvas, grid, opts)
  ‚îÇ
  ‚îú‚îÄ getWebGL2Context(canvas)
  ‚îÇ    ‚îî‚îÄ fails? ‚Üí return null (caller falls back to Canvas2D)
  ‚îÇ
  ‚îú‚îÄ buildFontAtlas(charset, fontSize, fontFamily)
  ‚îÇ    ‚îî‚îÄ ‚Üí atlas texture + charIndexMap
  ‚îÇ
  ‚îú‚îÄ compileShaders(vertSrc, fragSrc)
  ‚îú‚îÄ setupQuadVAO()          // unit quad + index buffer
  ‚îú‚îÄ uploadAtlasTexture()
  ‚îú‚îÄ buildInstanceBuffer()   // from frame 0
  ‚îú‚îÄ setupInstanceAttributes()
  ‚îÇ
  ‚îî‚îÄ renderFrame()           // first paint
```
## Render Flow (per frame)
```text
renderFrame()
  ‚îú‚îÄ buildInstanceBuffer(currentFrame, canvas, charIndexMap)
  ‚îú‚îÄ gl.bufferData(ARRAY_BUFFER, instanceData, DYNAMIC_DRAW)
  ‚îú‚îÄ gl.clear()
  ‚îî‚îÄ gl.drawArraysInstanced(TRIANGLE_STRIP, 0, 4, width * height)
```
- One draw call. Always.

## Fallback Strategy
- The factory (built in Task 1.2, but the pattern is set now):
```js
function createBestRenderer(canvasEl, grid, options) {
  // Try WebGPU first (Task 1.2)
  // Try WebGL2
  const gl = canvasEl.getContext('webgl2');
  if (gl) return createWebGL2Renderer(canvasEl, grid, options);
  // Fall back to Canvas2D
  return createRenderer(canvasEl, grid, options);
}
```
- For Task 1.1, createWebGL2Renderer itself returns null if context fails ‚Äî the caller handles fallback.

## Performance Targets
Metric | Target | Rationale
:--- | :---: | :---
80√ó24 render | < 1ms | Terminal-size grid, must be instant
200√ó100 render | < 2ms | Standard GRID canvas
500√ó500 render | < 8ms | Large canvas, still 120fps
1000√ó1000 render | < 16ms | Max spec size, 60fps floor
Atlas build | < 50ms | One-time init cost
Buffer rebuild | < 5ms (200√ó100) | Per-frame during animation

## Test Plan
tests/test-webgl2-renderer.js
  ‚îú‚îÄ Atlas: charset ‚Üí correct UV count, all chars mapped
  ‚îú‚îÄ Buffer: known frame ‚Üí expected Float32Array values
  ‚îú‚îÄ Hex parse: "#ff0000" ‚Üí [1, 0, 0]
  ‚îú‚îÄ API parity: every canvas-renderer method exists on webgl2
  ‚îú‚îÄ Fallback: null context ‚Üí returns null
  ‚îú‚îÄ Grid lines: toggle reflects in uniform
  ‚îú‚îÄ Frame navigation: goTo/next/prev update currentFrame
  ‚îú‚îÄ Performance: 200√ó100 buffer build < 5ms
  ‚îî‚îÄ Integration: create ‚Üí render ‚Üí setGrid ‚Üí destroy (no GL errors)

## What I Won't Do Yet
- Viewport culling (defer until 1000√ó1000 perf profiled)
- Per-cell background colors (uniform bg for now, per-cell in v2)
- Density-based shader effects (attribute is there, shader ignores it for now)
- Selection/hover highlight (Task 1.4 ‚Äî input system)

----

# Task 1.2: WebGPU Upgrade Path

## The plan:
src/renderers/
  canvas-renderer.js     ‚Üê Tier 0 floor (exists)
  webgl2-renderer.js     ‚Üê Tier 0.5 (exists, Task 1.1)
  webgpu-renderer.js     ‚Üê Tier 1 (Task 1.2, NEW)
  create-renderer.js     ‚Üê Factory: auto-detect best ‚Üí fallback chain

## Factory pattern:
```text
WebGPU available?  ‚Üí createWebGPURenderer()
  ‚Üì no
WebGL2 available?  ‚Üí createWebGL2Renderer()
  ‚Üì no
Canvas2D fallback  ‚Üí createRenderer()
```
## WebGPU renderer will share:
- Same public API (12 methods + 4 getters)
- Same font-atlas.js (atlas building is renderer-agnostic)
- Same instance-buffer.js (buffer layout is renderer-agnostic)
- New: WGSL shaders (replacing GLSL)
- New: GPUDevice + GPURenderPipeline setup

## Key differences from WebGL2:
- Compute shaders possible (future: density effects, particle systems)
- Explicit resource management (buffers, bind groups)
- Better mobile perf on newer devices
- Chrome 113+, Edge 113+, Firefox Nightly, Safari 18+ (TP)

--

## Recommendations & Comments
1. Skip Task 1.2 (WebGPU) ‚Äî defer to Phase 4 or 5

WebGPU coverage is still narrow (no Firefox stable, Safari partial). WebGL2 renderer already hits 0.03ms/frame on a 40√ó20 grid. Won't need WebGPU until 3D consumer or AI compute shaders. The factory file (create-renderer.js) is worth building now ‚Äî but it only needs the WebGL2‚ÜíCanvas2D fallback chain. Add the WebGPU slot later.
```text
Update:
Browser support
This initial release of WebGPU was made available in Chrome 113, on ChromeOS devices with Vulkan support, Windows devices with Direct3D 12 support, and macOS. Android support was later in Chrome 121 on devices running Android 12 and greater powered by Qualcomm and ARM GPUs. Linux and expanded support for existing platforms is coming soon.

WebGPU shipped in Firefox 141 on Windows and Safari 26, in addition to the implementation in Chrome.

For the latest updates on WebGPU's implementation status, can check the gpuweb implementation status page.

Library support
Many widely used WebGL libraries are already in the process of implementing WebGPU support or have already done so. This means that using WebGPU may only require making a single line change.

Babylon.js has full WebGPU support.
PlayCanvas announced initial WebGPU support.
TensorFlow.js supports WebGPU-optimized versions of most operators.
Three.js WebGPU support is in progress, see examples.
Both the Dawn library for Chromium and the wgpu library for Firefox are available as standalone package. They offer great portability and ergonomic layers that abstract operating system GPU APIs. Using these libraries in native applications makes it easier to port to WASM through Emscripten and Rust web-sys.
```
2. Prioritize Task 1.3 (textmode.js bridge) or 1.4 (input system)
Input system (1.4) unblocks the editor. Without it, the WebGL2 canvas is display-only. If the dist/index.html is to use WebGL2, that needs eventToGrid + click/drag working through the new renderer. I'd go 1.4 ‚Üí 1.3 ‚Üí 1.5.
3.  The dist/index.html decision
Currently it uses Canvas2D with everything inlined. At some point will want it to use the WebGL2 renderer with Canvas2D fallback. That's a Task 1.4 deliverable ‚Äî don't touch it until input is wired.
4. Export optimization (from open questions for phase 1)
The compact export flag is cheap to add. Consider doing it in 1.5 alongside the generator v2 work ‚Äî generators create large grids, which is where bloated exports hurt most.

"Task 1.4: Unified input system. Let's see the current dist/index.html event handling so we can design the abstraction."

--
# Task 1.4

## Input System Design
src/input/
  input-system.js      ‚Üê Unified: mouse + touch + keyboard ‚Üí grid events
  gesture-recognizer.js ‚Üê Optional: pinch-zoom, two-finger pan (mobile)
  key-bindings.js      ‚Üê Configurable shortcut map

- The key insight: the input system emits grid-level events (not DOM events). Every consumer ‚Äî the editor, the renderer, future tools ‚Äî subscribes to:

```js
// Grid-level events (renderer-agnostic)
onCellDown(x, y, button)     // mouse/touch start on cell
onCellMove(x, y)             // drag across cells  
onCellUp(x, y)               // release
onCellHover(x, y)            // passive hover (no button)
onAction(name, payload)      // keyboard shortcuts ‚Üí named actions
```

- The input system owns the pixel ‚Üí cell translation using renderer.eventToGrid() ‚Äî which both Canvas2D and WebGL2 already expose. The editor never touches clientX/offsetY directly.

## Current Input Surface Map
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  dist/index.html ‚Äî Current Input Architecture           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                         ‚îÇ
‚îÇ  CANVAS EVENTS (lines 524-534)                          ‚îÇ
‚îÇ  ‚îú‚îÄ mousedown  ‚Üí isDrawing=true, paint(e)               ‚îÇ
‚îÇ  ‚îú‚îÄ mousemove  ‚Üí if(isDrawing) paint(e), updateCellInfo ‚îÇ
‚îÇ  ‚îú‚îÄ mouseup    ‚Üí isDrawing=false     (on WINDOW)        ‚îÇ
‚îÇ  ‚îú‚îÄ touchstart ‚Üí isDrawing=true, paint(e)               ‚îÇ
‚îÇ  ‚îú‚îÄ touchmove  ‚Üí if(isDrawing) paint(e)                 ‚îÇ
‚îÇ  ‚îî‚îÄ touchend   ‚Üí isDrawing=false                        ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  KEYBOARD (line 869, on DOCUMENT)                       ‚îÇ
‚îÇ  ‚îú‚îÄ Ctrl+S     ‚Üí exportGrid()                           ‚îÇ
‚îÇ  ‚îú‚îÄ Ctrl+O     ‚Üí importGrid()                           ‚îÇ
‚îÇ  ‚îú‚îÄ Ctrl+N     ‚Üí showNewProjectModal()                  ‚îÇ
‚îÇ  ‚îú‚îÄ Space      ‚Üí togglePlayback()                       ‚îÇ
‚îÇ  ‚îú‚îÄ ArrowRight ‚Üí nextFrameAction()                      ‚îÇ
‚îÇ  ‚îú‚îÄ ArrowLeft  ‚Üí prevFrameAction()                      ‚îÇ
‚îÇ  ‚îú‚îÄ 1-9        ‚Üí select char from palette               ‚îÇ
‚îÇ  ‚îî‚îÄ e          ‚Üí toggleEraser()                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  TRANSLATION (line 363-368, inside renderer)            ‚îÇ
‚îÇ  ‚îî‚îÄ eventToGrid(e) ‚Üí {gridX, gridY}                     ‚îÇ
‚îÇ     uses getBoundingClientRect + DPI + touch||mouse     ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  STATE (module scope)                                   ‚îÇ
‚îÇ  ‚îú‚îÄ isDrawing (bool)                                    ‚îÇ
‚îÇ  ‚îú‚îÄ selectedChar (from palette onclick)                 ‚îÇ
‚îÇ  ‚îú‚îÄ eraserMode (from toggleEraser)                      ‚îÇ
‚îÇ  ‚îî‚îÄ renderer.isPlaying (inside renderer)                ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  UI BUTTONS (inline onclick, 30+ bindings)              ‚îÇ
‚îÇ  ‚îî‚îÄ NOT part of input system ‚Äî these are UI commands    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

# Task 1.6 ‚Äî Image ‚Üí .grid Importer

## DO:
- Extract the img-transform-animator ASCII algorithm into a pure GRID module
- Map image pixels to .grid cells with all 5 channels populated
- Add image-import button + preview modal to dist/index.html
- No AI, no server ‚Äî pure canvas pixel sampling

## Algorithm (from E:\co\img-transform-animator\index.tsx, lines 138-274)
- Canvas getImageData() per cell block
- Average R+G+B ‚Üí brightness (0‚Äì255)
- Contrast adjustment: ((brightness - 127.5) * factor) + 127.5
- Character ramp index: floor((brightness / 255) * rampLength)
- Per-cell color: rgb(avgR, avgG, avgB) ‚Üí #rrggbb
- Default ramp: @%#*+=-:. (dark ‚Üí light)

## Mapping to .grid Cell Channels
| img-transform value | .grid channel | Notes |
|---------------------|--------------|-------|
| ramp char           | char         | From brightness‚Üíramp lookup |
| rgb(r,g,b) ‚Üí hex    | color        | Converted to #rrggbb |
| 1 - brightness/255  | density      | 1=dark, 0=light |
| inferSemantic(char) | semantic     | Via grid-core.js |
| (none)              | channel      | Default {} |

## TEST:
- `node tests/run-all.js` ‚Üí test-image-importer.js (36 tests)
- Browser: open dist/index.html ‚Üí click üì∑ Image ‚Üí load photo ‚Üí preview ASCII ‚Üí Apply

## DOCUMENT:
- ARCHITECTURE.md: Task 1.6 added to Phase 1
- ACTION-PLAN.md: This section

# Task 1.5 ‚Äî Procedural Generators v2

## Problem Statement

The 7 generators in dist/index.html were built for Phase 0 proof-of-concept. They:
- All use a single flat `selectedColor` ‚Äî no per-cell color variation
- Populate `channel` not at all ‚Äî music, 3D, narrative consumers see empty channel objects
- Are not modular ‚Äî one 80-line switch statement inlined in HTML, not importable
- Use `inferSemantic(char)` passively rather than assigning semantic intentionally

Task 1.5 extracts, upgrades, and extends them into a proper source module.

---

## DO

### New File: `src/generators/generators.js`

Pure module. Zero DOM. Zero side effects. Node and browser compatible.

#### Generator signature (uniform across all 10)

```js
generatorName(width, height, options = {}) ‚Üí Cell[]
```

Returns a plain array of cell objects. The caller applies them to a frame. Pure and frame-agnostic.

#### Shared options

```js
{
  charset:   string,          // chars to draw from, e.g. '@#$%&*+=-.~'
  color:     '#rrggbb',       // base color (used by fixed and mono modes)
  colorMode: 'mono'           // DEFAULT ‚Äî same hue as color, brightness from density
           | 'fixed'          // all cells get exactly color
           | 'derived',       // per-cell hue from generator math (angle, phase, elevation)
  seed:      number,          // RNG seed for deterministic generators (default: Date.now())
  channel:   true,            // populate channel.audio + channel.spatial (default: true)
}
```

#### channel schema (all generators, when channel: true)

```js
cell.channel = {
  audio: {
    note:     0-127,    // MIDI. Y position maps to pitch (top row = highest note)
    velocity: 0-127,    // Math.round(density * 127)
    duration: 1,        // beats
  },
  spatial: {
    height:   0.0-1.0,  // equals density ‚Äî direct input for 3D heightmap consumer
    material: string,   // mirrors cell.semantic ('solid', 'void', 'fluid', 'emissive', ...)
  }
}
```

#### Generators ‚Äî ported from Phase 0 (upgraded: channel + intentional color + semantic)

| Name      | derived color source        | intentional semantic        |
|-----------|-----------------------------|-----------------------------|
| spiral    | hue from polar angle        | emissive at center, solid outward |
| wave      | hue from wave phase         | fluid where density < 0.35  |
| mandala   | hue from angle              | boundary at radial symmetry lines |
| noise     | random hue, sat from density| solid if density > 0.5, void if < 0.15 |
| geometric | fixed per shape             | boundary at perimeter, void interior |
| rain      | mono green default          | fluid throughout            |
| gradient  | hue sweeps 0-240 (red-blue) | density controls semantic tier |

#### New generators in v2

```
pulse   ‚Äî Concentric density rings from center. freq controls ring count.
          Useful as a music visualization base. density = cos(dist * freq * PI).
          options: { freq?: number (default 4) }

matrix  ‚Äî Vertical char streams, dense head, fading trail. Distinct from rain
          (rain is sparse random columns; matrix is a dense synchronized curtain).
          options: { streamDensity?: 0-1 (default 0.6), trailLength?: number }

terrain ‚Äî 2D noise heightmap using layered sine approximation (no deps).
          Elevation zones:  < waterLevel  -> void + fluid
                            < 0.5         -> solid (land)
                            < 0.75        -> solid (highland)
                            >= 0.75       -> emissive (peak/snow)
          derived color: deep blue -> green -> brown -> white by elevation
          options: { scale?: number (default 0.15), waterLevel?: 0-1 (default 0.3) }
```

#### Seeded RNG: mulberry32 (zero deps, deterministic)

```js
function mulberry32(seed) {
  return function() {
    seed |= 0; seed = seed + 0x6D2B79F5 | 0;
    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
```

#### Color helpers (zero deps)

```js
function hslToHex(h, s, l)        // h:0-360, s/l:0-100 -> '#rrggbb'
function monoFromHex(hex, density) // same hue as hex, brightness scaled by density
```

#### Registry export

```js
export const GENERATORS = {
  spiral, wave, mandala, noise, geometric, rain, gradient,
  pulse, matrix, terrain,
};
```

---

### dist/index.html updates

1. Inline `src/generators/generators.js` logic into the script block
2. Replace the `generate(type)` switch statement with `GENERATORS[type](W, H, opts)` dispatch
3. Add 3 new buttons in sidebar: Pulse, Matrix, Terrain
4. Add `colorMode` select to the sidebar (Fixed / Mono / Derived)

The new `generate(type)` dispatch:

```js
function generate(type) {
  const W = grid.canvas.width, H = grid.canvas.height;
  const generatorFn = GENERATORS[type];
  if (!generatorFn) { setStatus('Unknown generator: ' + type, true); return; }
  const cells = generatorFn(W, H, {
    charset:   grid.canvas.charset.replace(/ /g, ''),
    color:     selectedColor,
    colorMode: document.getElementById('colorModeSelect').value || 'mono',
    channel:   true,
  });
  const fi = renderer.current;
  grid.frames[fi] = { ...grid.frames[fi], cells };
  grid.meta.modified = new Date().toISOString();
  renderer.render();
  updateUI();
  setStatus('Generated: ' + type + ' (' + cells.length + ' cells)');
}
```

---

## TEST

File: `tests/test-generators.js` ‚Äî runs in Node.js (generators are pure math, zero DOM)

```
Coverage:
  - Every generator returns non-empty Cell[] for a 40x20 grid
  - Every cell has: char (string), color (#rrggbb), density (0-1), semantic (valid)
  - Every cell has channel.audio.note (0-127), channel.audio.velocity, channel.spatial.height
  - channel.audio.velocity === Math.round(cell.density * 127) for all generators
  - channel.spatial.height === cell.density for all generators
  - channel.spatial.material === cell.semantic for all generators
  - colorMode 'fixed'   -> all cells have exactly options.color
  - colorMode 'derived' -> varied colors (>= 2 distinct values in spiral, wave, gradient)
  - Seeded noise: seed 42 -> same output twice; seed 43 -> different output
  - terrain: cells classified into void/fluid/solid/emissive zones
  - GENERATORS registry has exactly 10 keys
  - pulse: density follows cosine pattern (center cell has max density)
  - matrix: cells only in columns, no horizontal spread beyond stream width
```

Add `test-generators.js` to `tests/run-all.js` suite.

---

## DOCUMENT

- ACTION-PLAN.md: add this spec now; add handover block post-implementation
- ARCHITECTURE.md: mark 1.5 complete; add `src/generators/generators.js` to project tree
- tests/run-all.js: add test-generators.js

---

## HANDOVER TARGET

"Open dist/index.html. Click Terrain, select Derived color mode, click generate.
The canvas fills with a biome map: void water cells, fluid shallows, solid land, emissive peaks.
Export the .grid. Open in a text editor. Inspect any cell: it has char, color, density,
semantic, AND channel.audio and channel.spatial with valid values.
Run: node tests/run-all.js ‚Äî all suites green."